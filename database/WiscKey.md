# WiscKey

#### 关键思想

`Key` 和 `Value` 分开，`Key` 存于 LSM 中，`Value` 存于 `vLog` 中

为了处理未排序的值（这需要在范围查询期间进行随机访问），WiscKey 使用 SSD 设备的并行随机读取特性

WiscKey 利用独特的崩溃一致性和垃圾收集技术来有效管理值日志。

WiscKey 通过删除 LSM 树日志而不牺牲一致性来优化性能，从而减少小写入带来的系统调用开销。

#### 设计目的

低写入放大：写入放大会引入额外不必要的**写入**

低读取放大：大读取放大会导致两个问题。首先，通过为每次查找发出多次读取，查找的吞吐量会显著降低。其次，加载到内存中的大量数据会降低缓存的效率。

SSD 优化：有效地利用了顺序写入和并行随机读取，以便应用程序能够充分利用设备的带宽。

支持使 LSM-tree 流行的现代功能

## 键值分离

![WiscKey -- Separating Keys from Values in SSD-conscious Storage · Columba  M71's Blog](..\img\wisckey-layout.png)

由于 `key` 的大小小于 `value`，导致 Wisckey 的 LSM 树会小于 LevelDB 的 LSM 树，搜索一个信息搜索的表文件更少，并且由于 `<key，addr>` 比 `<key，value>` 小，所以缓存中可以存更多的 `<key，addr>` 键值对，通过这个可以优化读取。

##### 插入

当用户在 WiscKey 中插入键值对时，该值首先被追加到 `vLog` 中，然后该键与该值的地址一起被插入到 LSM 树中（`<vLog-offset，value-size>`）删除一个键只需将其从 LSM 树中删除，而无需触摸 `vLog`。`vLog` 中的所有有效值在 LSM 树中都有相应的键；`vLog` 中的其他值无效，稍后将被垃圾收集。

##### 查询

当用户查询密钥时，首先在 LSM 树中搜索该密钥，如果找到，则检索相应值的地址。然后 WiscKey 从 `vLog` 中读取该值。请注意，此过程应用于点查询和范围查询。

## 挑战

##### 并行范围查询

在当前接口中，如果用户请求范围查询，则向用户返回迭代器。对于迭代器上请求的每个 `Next()` 或 `Prev()`，WiscKey 跟踪范围查询的访问模式。一旦请求连续的键值对序列，WiscKey 就开始依次从 LSM 树中读取许多以下键。从 LSM 树中检索的相应值地址被插入队列，多个线程将在后台并发地从 `vLog` 中获取这些地址。

##### 垃圾收集

在 `vLog` 中存储值的同时，我们还将相应的密钥与值一起存储。新的数据布局如图5所示：元组（密钥大小、值大小、密钥、值）存储在 `vLog` 中。

![Key Value分离](..\img/kv_split.png)

垃圾收集的时候，每次会从 `vLog` 的尾部读取一大块键值对，然后通过 LSM 查找多少键值对是有效的，将有效值添加到 `vLog` 的头部，然后释放之前占用的内存，并且更新尾部信息

为了避免在垃圾收集过程中发生崩溃时丢失任何数据，WiscKey 必须确保新添加的有效值和新尾部在实际释放空间之前在设备上是持久的。WiscKey 通过以下步骤实现了这一点。将有效值追加到 `vLog` 后，垃圾收集在 `vLog` 上调用 `fsync()`。然后，它以异步方式将这些新值的地址和当前尾部添加到 LSMtree；尾部存储在 LSM 树中，作为 `<"tail"， tail-vLog-offset>`。最后，回收 `vLog` 中的空闲空间。

##### 崩溃一致性

###### 崩溃一致性

是指数据库或系统在发生崩溃或故障时能够保持数据的一致性状态。具体来说，崩溃一致性确保在系统崩溃之后，数据库或系统能够以一种可预测且可恢复的方式恢复到一个已知的正确状态。

###### 数据一致性

在数据库系统中，为了提高性能，数据通常会首先被加载到内存中进行操作和处理。然而，由于内存中的数据易于丢失（如系统崩溃或断电），为了保证数据的持久性和可靠性，必须将数据写入磁盘或其他持久化存储介质中。数据一致性的关键是确保在内存中的数据修改操作（如插入、更新、删除）被正确地同步到磁盘中，以避免数据的丢失或不一致状态

当用户查询键值对时：

1. 如果 WiscKey 无法在 LSM 树中找到该键，因为该键在系统崩溃期间丢失了，即使该值在崩溃前已在vLog中写入，以后也会被垃圾收集。
2. 如果该键可以在LSM树中找到，则需要额外的步骤来保持一致性。在这种情况下，WiscKey首先验证从LSM树中检索的值地址是否在 `vLog` 的当前有效范围内，然后验证找到的值是否与查询的 `key` 相对应。如果验证失败，WiscKey 假设值在系统崩溃期间丢失，从 LSMtree 中删除`key`，并通知用户未找到 `key`。由于添加到 `vLog` 的每个值都有一个包括相应键的头，验证键和值是否匹配是直接的；如果需要，可以很容易地在头中添加一个 `Magic Number` 或校验和。

如果用户特别要求同步插入，LSM 树实现还能保证系统崩溃后键值对的用户持久性。WiscKey 通过在执行同步插入到其 LSM 树之前刷新 `vLog` 来实现同步插入。

#### 随机查询

1. > 先访问内存表是否命中key，如果找到地址信息判断是在内存中还是磁盘中(LRU缓存)

2. > 在内存中被缓存了value则直接返回，否则去磁盘中查找，根据vlog的名字找到具体的vlog文件

3. > 然后根据offset定位字节的首地址，根据size读取内容并返回

4. > 基于一定策略将整个vlog涉及的bolck缓存下来

#### 范围查询

1. > 根据迭代器 next 还是 prev判断 是在游标之前读还是之后读，

2. > 预先读取一定的key，交由底层的线程池异步的取ssd中获取数据

3. > 将异步结果缓存在内存中 等到迭代器的调用

#### 随机/顺序写入

1. > 将set操作先写入vlog日志中(存储key的作用之一就是既作为预写日志又作为值日志)

2. > 然后将返回的地址信息写入LSM中返回

3. > 返回写入成功

#### 合并压缩

1. > vlog分为多个文件 其中存在一个活跃vlog文件 用于写入数据作为head地址

2. > 最先写入的的日志在最后的vlog中 存在tail地址

3. > 多个写入线程运行在head地址处追加日志

4. > 而只有一个后台线程执行垃圾收集运行在尾部

5. > 每次选择一个vlog文件的内容去lsm结构中随机查询(可并行化) 将没有失效的key重新写会到head地址处重新追加到vlog中

6. > 然后更新lsm中这些key的新地址

7. > 并释放老的vlog文件

8. > 这一过程中需要先将数据写入新的vlog文件后刷新到固态硬盘后异步更新索引

9. > 最后删除老文件 以防止在此过程中进程崩溃造成数据丢失

#### 故障恢复

1. > 在wisckey的设计中预写日志就是值日志

2. > 因此引擎进程只需要定时保存 head和tail的地址即可

3. > 数据库恢复时需要获取崩溃前最新的地址然后从tail到head将日志进行redo即可

4. > 同时为了保证一致性在查询key时要做一些必要的一致性检查 

   1. > 当前key如果在tail与head索引范围外则忽略

   2. > 当前位置上的值具有的key与查询的key不匹配则忽略

   3. > 发生上述情况时，引擎直接返回错误信息