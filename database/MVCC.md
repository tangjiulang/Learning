# 什么是 MVCC

MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。
MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

# 什么是当前读和快照读

## 当前读

读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

## 快照读

### undolog

在操作数据之前,把需要操作的数据和事务记录备份到 undo log 中，目的就是为了保证原子性，如果一个事务执行中发生了故障，就可以通过 undolog 进行回滚

快照读，顾名思义，就是读取快照数据，也就是说当某个数据正在被修改的时候，也可以进行读取该数据，保证读写不冲突。刚刚提到 undolog，当我们对记录做了变更操作时，就会产生 undo 记录，undo 记录中存储的是老版数据，当一个旧的事务需要读取数据时，为了能够读取到老版本的数据，需要顺着 undo 列找到满足其可见性的记录，这个找满足可见行的记录依赖。就是说每次都是读取 undolog 中的数据。

# 数据库并发问题

## 读-读

不存在任何问题，也不需要并发控制

## 读-写

有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

### 脏读

脏读（Dirty read）是数据库中的一个概念，指的是当一个事务读取了另一个事务尚未提交的数据时发生的情况。在数据库中，事务是一组数据库操作的逻辑单位，可以包含一系列的读取和写入操作。通常，事务具有隔离性，这意味着并发执行的多个事务之间应该相互隔离，互不干扰。

脏读发生在一个事务读取了另一个事务未提交的数据时。假设有两个事务，事务 A 和事务 B。事务 A 在读取数据的同时，事务 B 修改了这些数据，但是尚未提交。如果事务 A 读取了事务 B 的未提交数据，那么它就发生了脏读。

脏读可能导致不一致的结果。因为事务 B 可能在后续的操作中回滚或提交修改的数据，如果事务 A 基于脏数据做出了决策或者执行了一些操作，这些操作可能会基于不准确的或者无效的数据。

### 幻读

幻读（Phantom read）是数据库中的一个概念，指的是在同一个事务中，对于相同的查询条件，重复执行查询时返回不同的结果集合的情况。

通常情况下，数据库事务在执行期间会锁定已读取的行，以确保事务期间不会发生数据的插入、更新或删除操作，从而保证数据的一致性。然而，幻读是在某些隔离级别下可能出现的现象。

幻读的典型场景是在并发事务中进行范围查询。假设有两个事务，事务 A 和事务 B，它们同时执行以下操作：

1. 事务 A 执行一个范围查询，返回满足条件的一组记录。
2. 事务 B 在事务 A 执行范围查询的同时，插入了一些新的记录，这些记录也满足事务 A 的查询条件。
3. 事务 A 再次执行相同的范围查询，返回的结果集合可能与之前的查询结果不同，因为新插入的记录现在也包括在结果中，导致了幻读。

幻读可能会导致数据的不一致性，因为同一个事务在不同的时间点执行相同的查询，却得到不同的结果。

### 不可重复读

不可重复读（Non-repeatable read）是数据库中的一个概念，指的是在同一个事务中，对于相同的查询条件，重复执行查询时返回不同的结果集合的情况。

通常情况下，数据库事务在执行期间会锁定已读取的行，以确保事务期间不会发生数据的插入、更新或删除操作，从而保证数据的一致性。然而，不可重复读是在某些隔离级别下可能出现的现象。

不可重复读的典型场景是在并发事务中进行读取操作。假设有两个事务，事务 A 和事务 B，它们同时执行以下操作：

1. 事务 A 执行一个查询，并获取了一些记录。
2. 事务 B 在事务 A 获取记录的同时，对这些记录进行了更新或删除操作。
3. 事务 A 再次执行相同的查询，返回的结果集合可能与之前的查询结果不同，因为数据已经发生了变化，导致了不可重复读。

不可重复读可能会导致数据的不一致性，因为同一个事务在不同的时间点执行相同的查询，却得到了不同的结果。这可能会对应用程序产生意外的影响，特别是在需要保证数据一致性的场景下。

## 写-写

有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

### 第一类更新丢失

回滚丢失，Lost update

 A事务撤销时，把已经提交的B事务的更新数据覆盖了。

| A                            | B                            |
| ---------------------------- | ---------------------------- |
| 查询 id = 1 的数据 age = 500 |                              |
|                              | 更新 id = 1 的数据 age = 200 |
| 更新 id = 1 的数据 age = 100 |                              |
|                              | 提交                         |
| 提交                         |                              |
| 回滚事务                     |                              |
| age 恢复 500，更新失败       |                              |

### 第二类更新丢失

覆盖丢失/两次更新问题，Second lost update

A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失

| A                            | B                            |
| ---------------------------- | ---------------------------- |
| 查询 id = 1 的数据 age = 500 |                              |
|                              | 更新 id = 1 的数据 age = 100 |
|                              | 提交事物                     |
| 更新 id =1的数据 age = 200   |                              |
| 提交事物                     |                              |
|                              | age被修改为200，更新丢失     |

# MVCC 的好处

MVCC 是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以 MVCC 可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题

由于传统悲观锁的性能不佳，所以加上 MVCC 后，主要有两种组合方式来解决：

- MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决读写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

# MVCC 原理

MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的。

## 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的 DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID 等字段

- DB_TRX_ID：6byte，最近修改(修改/插入)事务 ID：记录创建这条记录 / 最后一次修改该记录的事务 ID
- DB_ROLL_PTR：7byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）
- DB_ROW_ID：6byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB会自动以 DB_ROW_ID 产生一个聚簇索引
- 实际还有一个删除 flag 隐藏字段，既记录被更新或删除并不代表真的删除，而是删除 flag 变了

| name    | age  | DB_TRX_ID（隐式主键） | DB_ROLL_PTR（事务 ID) | DB_ROW_ID（回滚指针） |
| ------- | ---- | --------------------- | --------------------- | --------------------- |
| Atangyl | 21   | 1                     | 1                     | 0x123456              |

## undo log

- insert undo log：代表事务在insert新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃
- update undo log：事务在进行 update 或 delete 时产生的 undo log，不仅在事务回滚时需要，在快照读时也需要。所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除