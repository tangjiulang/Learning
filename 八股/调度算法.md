# 进程调度

## 先来先服务调度算法

## 最短作业优先调度算法

## 高响应比优先调度算法

## 时间片轮转调度算法

## 最高优先级调度算法

## 多级反馈队列调度算法

# 页面置换

## 缺页异常

![缺页中断的处理流程](./../img/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png)

 当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。

## 最佳页面置换算法

**置换在「未来」最长时间不访问的页面**。

但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。

所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。

## 先进先出置换算法(FIFO)

**选择在内存驻留时间很长的页面进行中置换**

## 最近最久未使用的置换算法(LRU)

**选择最长时间没有被访问的页面进行置换**

在每次访问内存时都必须要更新「整个链表」，开销比较大，实际应用中比较少使用

## 时钟页面置换算法

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：

- 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
- 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：

<img src="./../img/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法" style="zoom:50%;" />

了解了这个算法的工作方式，就明白为什么它被称为时钟（*Clock*）算法了。

## 最不常用算法(LFU)

**当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰**。

要增加一个计数器来实现，这个硬件成本是比较高

LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

# 磁盘调度

## 先来先服务(FCFS)

如果每个磁道的距离很分散，效率比较低

## 最短寻道时间优先(SSF)

距离最远的磁道可能永远访问不到

## 扫描算法(Scan)

**磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（\*Scan\*）算法**

扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。

## 循环扫描算法(CScan)

只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且**返回中途不处理任何请求**，该算法的特点，就是**磁道只响应一个方向上的请求**

## LOOK 与 C-LOOK算法

**磁头在移动到「最远的请求」位置，然后立即反向移动。**

### LOOK

对应的是 Scan

磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，**反向移动的途中会响应请求**。

### C-LOOK

对应的是 CScan

磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，**反向移动的途中不会响应请求**。

但是反向的时候还是会到最始端