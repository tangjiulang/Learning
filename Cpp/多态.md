## 多态

多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。

#### 需要注意

1. 只有类的成员函数才能声明为虚函数，虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。
2. 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
3. 内联函数（inline）不能是虚函数，因为内联函数不能在运行中动态确定位置。
4. 构造函数不能是虚函数。
5. 析构函数可以是虚函数，而且建议声明为虚函数。

#### 隐藏

除了重载与覆盖（重写），C++还有隐藏。隐藏是指派生类的函数屏蔽了与其同名的基类函数。隐藏规则如下：

1. 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual 关键字，基类的函数将被隐藏（注意别与重载混淆，重载是在同一个类中发生）。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆，覆盖有virtual关键字）。

```cpp
#include<iostream>
using namespace std;

class Base {
public:
	virtual void f(float x) {
		cout<<"Base::f(float)"<< x <<endl;
	}
	void g(float x) {
		cout<<"Base::g(float)"<< x <<endl;
	}
	void h(float x) {
		cout<<"Base::h(float)"<< x <<endl;
	}
};
class Derived : public Base
{
public:
        //子类与基类函数同名，有virtual关键字，运行时多态
	virtual void f(float x) {
		cout<<"Derived::f(float)"<< x <<endl;   //多态、覆盖
	}
        //子类与基类函数同名，且无virtual关键字，隐藏
        //参数不同的隐藏
	void g(int x)  {
		cout<<"Derived::g(int)"<< x <<endl;     //隐藏
	}
        //参数相同的隐藏
	void h(float x) {
		cout<<"Derived::h(float)"<< x <<endl;   //隐藏
	}
};
int main(void) {
	Derived d;        //子类对象
	Base *pb = &d;    //基类类型指针，指向子类对象
	Derived *pd = &d; //子类类型指针，指向子类对象
	// Good : behavior depends solely on type of the object
	pb->f(3.14f);   // Derived::f(float) 3.14  调用子类方法，多态
	pd->f(3.14f);   // Derived::f(float) 3.14  调用自己方法

	// Bad : behavior depends on type of the pointer
	pb->g(3.14f);   // Base::g(float)  3.14 
	pd->g(3.14f);   // Derived::g(int) 3 

	// Bad : behavior depends on type of the pointer
	pb->h(3.14f);   // Base::h(float) 3.14
	pd->h(3.14f);   // Derived::h(float) 3.14
	return 0;
}
```

## 虚函数，纯虚函数

在派生子类中对虚函数和纯虚函数的个性化实现，都体现了“多态”特性。但区别是：

- 子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；
- 子类如果不提供纯虚函数的实现，编译将会失败。尽管在基类中可以给出纯虚函数的实现，但无法通过指向子类对象的基类类型指针来调用该纯虚函数，也即不能作为子类相应纯虚函数的备选方案。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路。）

在上述例子中，我们首先定义了一个基类base，基类有一个名为vir_func的虚函数，和一个名为func的普通成员函数。类A，B都是由类base派生的子类。然后我们定义三个base*类型的指针Base、a、b分别指向类base、A、B。可以看到，当使用这三个指针调用func函数时，调用的都是基类base的函数。而使用这三个指针调用虚函数vir_func时，调用的是指针指向的实际类型的函数。最后，我们将指针b做强制类型转换，转换为A*类型，然后分别调用func和vir_func函数，发现普通函数调用的是类A的函数，而虚函数调用的是类B的函数。以上，我们可以得出结论“**当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定**”。

这时如果sizeof一个类D的对象，会发现比类C的对象大4个字节。多出来的这4个字节就是实现虚函数的关键----虚函数表指针vptr。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数fun_b()具体实现所对应的位置。注意，普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，sizeof的值也只包括vptr和var所占内存的大小，并且vptr通常会在对象内存的最起始位置。另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr（指向一个虚函数表），而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。因此，虚函数实现的过程是：**通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。**所以虚函数的调用时由指针所指向内存块的具体类型决定的。

构造函数不能是虚函数，析构函数最好是虚函数

## 虚函数 vs 纯虚函数，如何选用？

1. 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。
2. 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。