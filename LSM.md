# LSM

#### 就地更新和非就地更新

就地更新指的是在原有数据的基础上进行修改，而不需要额外的空间来存储结果。在就地更新中，修改操作直接作用于原始数据，原始数据被更新为新的值。这种更新方式通常具有较低的空间复杂度，因为不需要额外的存储空间。然而，就地更新可能会改变原始数据，因此需要谨慎处理，确保不会对其他依赖该数据的部分产生意外的影响。

非就地更新指的是在进行修改操作时，创建一个新的数据副本，将修改后的结果存储在副本中，而原始数据保持不变。这种更新方式通常需要额外的空间来存储结果，因此会有较高的空间复杂度。非就地更新的优点是原始数据不会被修改，可以保留数据的完整性，适用于对原始数据的保护或需要同时保留多个版本的情况。

#### 顺序 I/O 和随机 I/O

随机IO就是读写的内容分散在磁盘的不同位置,需要来回查找所以效率低;

顺序IO就是读写的内容集中存储在磁盘的一块，从前到后依次读取，免去了查找的过程，所以效率高。

## LSM 组成

<img src="img\793413-20201025165206001-1985214304.png" alt="LSM 树详解- -Finley- - 博客园" style="zoom:50%;" />

#### `memtable`

`MemTable` 是在**内存**中的数据结构，用于保存最近更新的数据，会按照 `Key` 有序地组织这些数据，`LSM` 树对于具体如何组织有序地组织数据并没有明确的数据结构定义。

因为数据暂时保存在内存中，内存并不是可靠存储，如果断电会丢失数据，因此通常会通过 `WAL` (Write-ahead logging，预写式日志)的方式来保证数据的可靠性。

#### `immutable memtable`

当 `MemTable` 达到一定大小后，会转化成 `Immutable MemTable`。`Immutable MemTable` 是将转 `MemTable` 变为 `SSTable` 的一种中间状态。写操作由新的 `MemTable` 处理，在转存过程中不阻塞数据更新操作。

#### `SStable`

**有序键值对**集合，是LSM树组在**磁盘**中的数据结构。为了加快 `SSTable` 的读取，可以通过建立 `key` 的索引以及布隆过滤器来加快 `key` 的查找。

#### 特点

`SSTable` 将所有的数据插入，修改，删除等操作记录保存到内存中，当记录达到设定的值的时候，再批量的顺序写入到磁盘中，这样的设计是为了顺序写，并且不用修改之前的 `SSTable` 的 `key`，保证了顺序写

但同时也有一些问题：

1. 不断的修改使我们只需要最新修改的那条信息，那么之前的信息就冗余了，但是它仍然占用了存储空间，所以我们需要对它进行 `Compact` 操作消除冗余
2. 读取时需要从最新的开始顺序查询，直到找到记录，最坏的情况我们需要遍历所有的 `SSTable` 才能找到某条信息

## Compact

`Compact` 将多个 `SSTable` 合并成一共，然后将无用的数据清除掉，合并的新文件也根据 `key` 排序的

#### Size-Tiered Compaction Strategy(STCS)

当 `immutable memtable` 逐步写入到 `SSTable` 中的时候，如果 `small SSTable` 达到一定的阈值，就合并成一共 `middle SSTable`，如果 `middle SSTable` 到达一定的阈值时，合并成一个 `big SSTable`，以此类推

总的来说，STCS 就是将 `SSTable` 按大小分类，相似大小的 `Table` 分在同一类，然后将多个同类的 `SSTable` 合并到下一个类别。

STCS 能有效的减少 `SSTable` 的数量，同一份数据在 `Compact` 期间拷贝的次数比较小（写入放大较小），但是它有很大的缺陷，空间放大，还有很大的读放大

##### 空间放大

空间放大指在 `Compact` 的过程中，数据膨胀，需要大量的额外空间

我们假设所有的操作都是插入一个新数，我们假设，`SSTable` 每 2 个会触发一次 `Compact`，`Memtable` 的大小也是 2，假如我们插入 8 个数

![image-20231223151546997](img/image-20231223151546997.png)

最后得到的 `SSTable`， 几次 `Compact` 中我们需要一共 24 个块来保存数，最多同时存在 16 个数据块，大大超过了原有数据所占空间，导致了空间放大

实际情况中，还有许多原因导致数据膨胀，比如某个 `SSTable` 中的某个数据是读操作，这个文件还被引用，也不能立即删除，所以在 `Compact` 过程中，新老文件共存，产生临时空间放大，这就使得系统不得不使用比实际数据更大的磁盘空间来保证 `Compact` 顺利执行，产生昂贵的代价。

同时，如果我们每次 `memtable` 的数据都是一样的

![image-20231223154324007](img/image-20231223154324007.png)

此时，我们对于同样的数据，有三个不同的副本，并且不能进行 `Compact`，这就导致了大量的空间被浪费，所以对于覆盖写较少的场景，STCS 的空间放大尚可接受；但是对于覆盖写频繁的场景，STCS 便不再是一个很好的选择。

#### Leveled Compaction Strategy(LCS)

##### 特点：

`SSTable` 的大小可控，所有的 `SSTable` 的大小都是一样的

LCS 在合并的时候，保证除了 Level 0 (L0) 之外的其他 Level 有序且无覆盖

LCS除了 L0 之外，每层文件的总大小成指数增长，L1 是 10 个，L2 是 100 个， L3 是 1000 个

LCS 的工作原理如下图所示：

<img src="img/0HC8TdP7PGENRCRe-.png" alt="Getting Started with LSM Compaction Mechanism | Medium" style="zoom:50%;" />

内存中 `memtable` 转到 L0 中，然后 L0 达到一定阈值之后，将 L0 的所有文件和与 L1 有覆盖的文件进行合并，然后生成新文件（如果文件大小超过阈值，会切成多个）到 L1，L1 中的文件时全局有序的，不会出现重叠的情况；

当 L1 的文件数量达到阈值时，会选取 L1 中的一个 `SSTable` 与 L2 中的多个文件做合并，假设 L1 有 10 个文件，那么一个文件便占 L1 数据量的 1/10，假设每层包含的 key 范围相同，那么 L1 中的一个文件理论上会覆盖 L2 层的 10 个文件，因此会选取 L1 中的一个文件与 L2 中的 10 个文件一起 Compact，将生成的新文件放到 L2；

当 L2 文件数量达到阈值时，处理方式同上，如此往复。

##### 如何解决空间放大问题：

1. LCS 不会像 STCS 一样，有明显的临时磁盘占用问题，由于 LCS 中的 SSTable 的大小是固定的，不会产生超大文件，并且层与层之间只会调用 11 个 SSTable，临时空间很小
2. LCS 不会被重复数据困扰，每一个 SSTable 都是有序的，所以每一层 SSTable 不会有重复数据出现。

##### 读放大

读放大指的是，读取一次数据，会产生多次 io，io 次数即为读放大（注：这里是以 io 次数来做的定义，有些文章是以数据量放大倍数来定义，笔者觉得应该将两者结合起来定义更准确）。对于 STCS 来说，由于每层内的 SSTable 数据可以相互重叠，因此最坏情况下，需要遍历层内所有 SSTable 才能获取。而对于 LCS 来说，如果数据确定在某层（除 L0）的话，只需要定位到数据所在的 SSTable，只访问一个 SSTable 即可，所以理论上来讲，LCS 的读放大要比 STCS 好得多。

##### 写入放大

写入放大指的是实际写入的物理数据量是写入数据量的多倍。

LCS 虽然解决了空间放大，但是也引入了另一个问题 -- **写入放大**

如果一个数据要被写入到 L4 的话，就会被写入 6 次，分别是 L0，L1，L2，L3，L4，WAL