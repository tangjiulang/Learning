# B Tree

B树单一节点拥有的最多子节点数量，称为B树的“阶”。一个m阶的B树，具有如下几个特征：

根节点至少有两个子节点。

每个中间节点都包含k-1个元素（也被称为关键字）和k个孩子，其中m/2 <= k <= m。

每一个叶子节点都包含k-1个元素，其中m/2 <= k <= m。

所有的叶子节点都位于同一层。

每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

## 插入操作

1. 检查 root 是否满了，如果满了执行 split 操作
2. 如果没满，就尝试插入到 root 的子结点
3. 如可以就递归往下放，直到到达叶子结点或者观察到下一层满了
4. 如果在某一层发现下一层放不下了，就需要进行 split 操作
5. split 操作中，我们会将即将下放的结点作为参数传入 split，这里将该结点称为规范结点
6. 在 split 中，我们会新建一个结点，结点类型和规范结点相同，然后将规范结点的 t - 1 的内容都复制给新结点，如果不是叶子结点，同时也会将子结点的内容也分一半给新结点
7. 然后将新结点插入到 father 结点中，同时将规范结点 t - 1 的内容作为中点插入到 father 结点中

## 查询操作

从 root 开始，根据 key 的大小找到对应的 key，如果不等，就向下找，直到找到或者到叶子结点依旧没有找到

## 删除操作

1. 检查 key 是否在 B-tree 中，如果不在直接返回
2. 如果删除的是叶子结点，直接删除
3. 如果我们删除的是 indexkey，那么我们看 C[indexkey] 的大小是否超过了 t - 1，如果超过了 t - 1，就将删除的 key 换成左边最大关键字
4. 如果上面不满足，我们看右边 C[indexkey + 1] 的大小是否超过了 t - 1，如果超过了 t - 1，就将删除的 key 换成左边最小关键字
5. 如果都不满足，说明右边 $n \le t - 1$，左边 $n \le t - 1$，左右加起来满住 $\le 2 * t - 2$，也就是说可以合并，那么我们就直接将左右两个结点进行合并即可