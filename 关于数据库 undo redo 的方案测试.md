# 关于数据库 undo redo 的方案测试

## 方案一：直接使用 SQLite 进行 undo redo

### 实现：

SQLite 本身并不直接支持 Undo/Redo 功能，但可以通过事务中的 savepoint 和 rollback 进行模拟。

开启事务，在一段操作后使用 savepoint 进行保存，同时将这段操作中有关数据修改的部分保存下来，在需要 undo 时通过 rollback 回滚到指定的 savepoint，在需要 redo 的时候回放保存的数据修改操作

### 特点：

实现较为复杂，需要 SQLite 进行进一步封装

可以手动管理设置 savepoint 的时机，在需要同一时间修改多个表的情况下可以控制 savepoint 的个数，减少版本数量

### 开源协议：

MIT License

### 效率：

|   次数   | 数据大小 |  时间  |
| :------: | :------: | :----: |
| 10000000 |   1kb    | 23.7 s |
| 1000000  |   1kb    | 2.4 s  |
|  100000  |   1kb    | 237 ms |
|   1000   |   1kb    |  4ms   |

### 优化思路：

由于程序中的栈是有限的，后续开发中可以设置最大回滚版本，将最大回滚版本外的数据状态写入磁盘中。

如果需要实现无限回滚，回滚版本外的相邻两个状态之间的差距使用 SQL 语句保存进入日志，然后通过日志进行最大回滚版本外的 undo

## 方案二：使用 SQLite 的分支 litetree 进行 undo redo

### 实现：

直接使用 litetree 中的分支语句实现 undo redo

### 特点：

实现简单，添加 litetree 库后可以直接使用

自动管理版本，无需手动记录变更

但是可能会产生额外版本，在多个表同时进行更改的时候会产生很多额外版本，影响 redo undo 的效率

### 开源协议：

 MIT License

### 效率

|   次数   | 数据大小 |   时间   |
| :------: | :------: | :------: |
| 10000000 |   1kb    |   34 s   |
| 1000000  |   1kb    |  3.4 s   |
|  100000  |   1kb    |  351 ms  |
|   1000   |   1kb    | 16-70 ms |

## 总结

litetree 的开发难度小于直接使用 SQLite

SQLite 能实现更精准的版本控制